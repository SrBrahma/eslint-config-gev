import fs from "fs"
import path from "path"

/** Don't override those rules */
const blacklist = ["indent"]

const rootPath = path.resolve(import.meta.dir, "..")
const outFilePath = path.resolve(rootPath, "ts-extensions.js")

type RuleAndValue = { rule: string; value: unknown }

/**
 * Some TS rules extends JS rules. We need to disable the JS rule to use the TS one.
 *
 * This is a cool automatic hack to do this convertion.
 */
const getTsExtensionsRules = (): Array<RuleAndValue> => {
  const config = JSON.parse(
    Bun.spawnSync(
      [
        "bunx",
        "eslint",
        "-c",
        "./scripts/.eslintrcNoBiome.cjs",
        "--print-config",
        "dont-care.js",
      ],
      {
        cwd: rootPath,
        stderr: "inherit",
      },
    ).stdout.toString(),
  ) as { rules: Record<string, Array<unknown>> }

  const jsRulesRecord = config.rules
  const glob = new Bun.Glob("*.js")

  const tsRules = [
    ...glob.scanSync({
      cwd: path.resolve(
        rootPath,
        "node_modules/@typescript-eslint/eslint-plugin/dist/rules",
      ),
    }),
  ].map((s) => s.replace(".js", ""))

  const tsRulesThatExtends = tsRules
    // Gets the JS active rules that have TS extensions
    .filter((tsRule) => Boolean(jsRulesRecord[tsRule]))
    // Remove problematic rules
    .filter((tsRule) => !blacklist.includes(tsRule))
    // Sort results to avoid diff
    .sort()

  const rules: Array<RuleAndValue> = tsRulesThatExtends
    // Add the values from JS
    // biome-ignore lint/style/noNonNullAssertion: <always defined>
    .map((tsRule) => ({ rule: tsRule, value: jsRulesRecord[tsRule]! }))
    // Ignore rules that are disabled
    .filter(({ value }) => value[0] !== 0 && value[0] !== "off")

  return rules
}

const getReplaceString = ({ rule, value }: RuleAndValue) =>
  `"${rule}": 'off',\n"@typescript-eslint/${rule}": ${JSON.stringify(value)},`

const writeFile = (rules: Array<RuleAndValue>) => {
  fs.writeFileSync(
    outFilePath,
    `/**
  * File smartly and automatically generated by my scripts/makeTsExtensions.ts
  *
  * Some Typescript rules extends the JS rules to also support TS syntax.
  * This disables the JS rules and have their values in the TS corresponding rules.
  */

 module.exports = {
   rules: {
${rules.map((r) => `    ${getReplaceString(r)}`).join("\n\n")}
   }
 }
 `,
  )
}

const main = () => {
  const rules = getTsExtensionsRules()

  writeFile(rules)

  Bun.spawnSync(
    ["bunx", "@biomejs/biome", "check", outFilePath, "--apply-unsafe"],
    {
      cwd: rootPath,
      stderr: "inherit",
    },
  )
}

main()
