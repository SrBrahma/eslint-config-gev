import fs from 'fs';
import path from 'path';
import { execa, execaCommandSync } from 'execa';
import { globbySync } from 'globby';

/** Don't override those rules */
const blacklist = ['indent'];

const rootPath = path.resolve();
const filePath = path.join(rootPath, 'ts-extensions.js');

/**
 * Some TS rules extends JS rules. We need to disable the JS rule to use the TS one.
 *
 * This is a cool automatic hack to do this convertion.
 */
function makeTsExtensions() {
  /** Record<string, any> */
  const config = JSON.parse(
    execaCommandSync('npx eslint --print-config dont-care.js', {
      cwd: rootPath,
    }).stdout,
  );

  /** Record<string, any[]> */
  const jsRulesRecord = config.rules;

  /** string[] */
  const tsRules = globbySync('*.js', {
    cwd: path.join('node_modules/@typescript-eslint/eslint-plugin/dist/rules'),
  }).map((s) => s.replace('.js', ''));

  const tsRulesThatExtends = tsRules
    // Gets what JS active rules have TS extensions
    .filter((tsRule) => !!jsRulesRecord[tsRule])
    // Remove problematic rules
    .filter((tsRule) => !blacklist.includes(tsRule))
    // Sort results
    .sort()
    // Add the values from JS
    .map((tsRule) => [tsRule, jsRulesRecord[tsRule]])
    // Remove rules that are disabled
    .filter(([, [v]]) => v !== 0 && v !== 'off');

  writeFile(tsRulesThatExtends);
}

function writeFile(rules) {
  const data = `/**
 * File smartly and automatically generated by my scripts/makeTsExtensions.js
 *
 * Some Typescript rules extends the JS rules to also support TS syntax.
 * This disables the JS rules and have their values in the TS corresponding rules.
 */

module.exports = {
  rules: {
${rules.map((r) => getReplaceString(...r)).join('\n\n')}
  }
}
`;

  fs.writeFileSync(filePath, data);

  // ESLint it!
  execa('npx', ['eslint', filePath, '--fix'], { cwd: rootPath });
}

function getReplaceString(rule, value) {
  return `['${rule}']: 'off',\n` + `['@typescript-eslint/${rule}']: ${JSON.stringify(value)},`;
}

makeTsExtensions();
